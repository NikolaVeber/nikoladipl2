<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>gov.nasa.jpf.traceEmitter package</title>
</head>
<body>
This document is the API specification of the Trace Server, extension of the 
<a href="http://babelfish.arc.nasa.gov/trac/jpf/wiki/intro/start">JPF verification system</a>.

<p>
During the execution of the SUT (System Under Test), JPF generates trace that consists of executed instructions and is kept in memory,
competing with SUT heap and state storage. Production code SUT, can create trace that contain millions of steps
(<code>Instruction</code> objects). The trace cannot be augmented with custom properties, nor trace output can be changed.
In order to store custom trace data, one has to implement <code>gov.nasa.jpf.Listener</code>, create its own data structure and deal with
state backtracking and restoration. Trace analysis is only possible "on-the-fly", i.e. when JPF is still running. 
</p>   

<p>
One possible solution of the problem described above is to configure a "trace server" interface that can  
<a href="http://babelfish.arc.nasa.gov/devel/listener">listen</a> on 
all JPF notifications (events) and stores them in a database. Once such database is created, post mortem analyzers can be used to find out about defects
etc. Listeners like the <code>DeadlockAnalyzer</code> really should be implemented that way, since there is no need to run them while JPF is
still searching for a deadlock. Post mortem analyzers does not only speed up JPF in the first place, but also avoid having to re-run JPF
on a large system under test if you need to try several trace analyzers.<br/>

JPF extensions would also benefit from the ability to augment traces with their custom information. 
The Trace Server framework should therefore be extensible enough to allow listeners to augment a trace with extra data.
</p>

<h2 id="Architecture">Architecture</h2>
<p>
<a style="padding:0; border:none" href="../trace-server.gif">
<img style="display:block; margin-left:auto; margin-right:auto; border:none" src="../trace-server.gif" 
alt="Trace server architecture" title="Trace server architecture" /></a>
</p>

<p>
The trace server contains a database and two front ends, one for storing and one for querying data. 
During the execution of the SUT by JPF, a {@link gov.nasa.jpf.traceEmitter trace emitter} captures events from JPF listener, add them some 
property values, and stores then using the {@link gov.nasa.jpf.traceServer.traceStorer trace storer} interface. 
This decoupling allows arbitrary emitter to listen for events, allowing JPF extensions to easily augment the trace information database
with custom data. To simplify the creation of trace emitters, a {@link gov.nasa.jpf.traceEmitter.TraceEmitter base trace emitter}
take takes care of tying events to the right JPF states and initializes events with the default set of properties. 
Custom trace emitter then augments that empty state information with data.
</p>
<p>
Trace Storer provide database-independent API to store events. This allows the use of two databases, both being the graph database,
{@link gov.nasa.jpf.traceServer.traceStorer.inMemory in-Memory} and {@link gov.nasa.jpf.traceServer.traceStorer.neo4j neo4j}.  
</p>

<p>
Between the trace emitter and the trace storer ia s {@link gov.nasa.jpf.traceEmitter.traceFilter trace filter}, that allows multiple JPF extensions
to use the same trace emitter by just filtering out uninteresting events. Filters are connected in a chain and enable the filtering in several stages.
All events that are not filtered, will be saved by using a {@link gov.nasa.jpf.traceEmitter.traceFilter.TailTraceFilter} 
filter that only forwards events to registered trace storer.
Trace filter interface provides another important feature, multiple trace storers to be used for storing the trace. 
(see {@link gov.nasa.jpf.traceEmitter.traceFilter.GeneralTailTraceFilter}) 
</p>

<p>
The trace server may reside on a different machine (host) than JPF, allowing both entities to use the full amount of memory on their machines.
(see {@link gov.nasa.jpf.traceServer.traceStorer.remote remote trace server})
</p>

<p>
On the analysis side, a {@link gov.nasa.jpf.traceAnalyzer trace analyzer}</i> queries the database by using the 
{@link gov.nasa.jpf.traceServer.traceQuery trace query} interface, generating a number of reports as a result. 
Report generation in the analyzer allows events generated by extensions to be included in the trace.
</p>
</p>
Trace query provides interface for querying data independently of database format. Querying is performed by providing the 
{@link gov.nasa.jpf.traceServer.traceQuery.TracePredicate trace predicate}. Entire event space or only the last path can be queried.
</p> 
<p>
Trace analysis may be performed during the execution (on the fly) or post-mortem, after the program has terminated. Various 
{@link gov.nasa.jpf.traceAnalyzer.TraceAnalyzer analyzers} can be run to analyze the same trace, e.g.
{@link gov.nasa.jpf.traceAnalyzer.MethodAnalyzer method analyzer} and 
{@link gov.nasa.jpf.traceAnalyzer.OverlappingMethodAnalyzer overlapping method analyzer}.
Trace analyzer can define its own report (print) method, or may use the services of a printer or printers from 
the {@link gov.nasa.jpf.traceServer.printer printer} package.
</p> 
 
<p>
Since the new mechanism for trace storing is introduced, a new trace printer had to be implemented.
{@link gov.nasa.jpf.traceServer.printer.ConsoleTracePrinter Console trace printer} is a replacement for JPF's 
<code>gov.nasa.jpf.report.ConsolePublisher</code>. The output of this printer can be augmented by assigning  
{@link gov.nasa.jpf.traceEmitter.PropertyCollection#TRACE_EXTRA_DATA extra data property} a value to each event.<br/>

{@link gov.nasa.jpf.traceServer.printer.TracePrinter Trace printer} allows adding a custom 
{@link gov.nasa.jpf.traceServer.printer.EventPrinter event printer} for every 
{@link gov.nasa.jpf.traceServer.traceStorer.EventTypes.eventGroupType group of events}. Trace printer can be used by either JPF
for reporting the trace, or by analyzer for reporting the results of the analysis.    
</p>

<p>
Examples of how to extend various parts of the trace server can be found in the {@link gov.nasa.jpf.traceServer.extensions extensions} package. 
</p>


</body>
</html>